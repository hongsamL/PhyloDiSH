[{"name":"server.R","content":"#\n# This is the server logic of a Shiny web application. You can run the\n# application by clicking 'Run App' above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    https://shiny.posit.co/\n#\n\nlibrary(shiny)\nlibrary(DT)\nlibrary(ape)\nsource(\"subsampling.R\")\nsource(\"utils.R\")\n\n# Workaround for Chromium Issue 468227\ndownloadButton <- function(...) {\n  tag <- shiny::downloadButton(...)\n  tag$attribs$download <- NULL\n  tag\n}\n\n# Example data\nexample_tree_text <- \"((((A1_A,A2_A),(A3_A,A4_A)),((B1_B,B2_B),((B3_B,B4_B),(B5_B,B6_B)))),((C1_C,C2_C),C3_C));\"\nexample_metadata <- data.frame(\n  name = c(\"A1_A\",\"A2_A\",\"A3_A\",\"A4_A\",\"B1_B\",\"B2_B\",\"B3_B\",\"B4_B\",\"B5_B\",\"B6_B\",\"C1_C\",\"C2_C\",\"C3_C\"),\n  loc = c(\"A\",\"A\",\"A\",\"A\",\"B\",\"B\",\"B\",\"B\",\"B\",\"B\",\"C\",\"C\",\"C\")\n)\n\n# Define server logic required to draw a histogram\nserver <- function(input, output, session) {\n\n    # Reactive values to store the tree and metadata\n    values <- reactiveValues(\n        tree = NULL,\n        metadata = NULL,\n        subsampled_tree = NULL,\n        subsampled_metadata = NULL,\n        subsampled_df = NULL,\n        show_tree_info_plot = NULL\n    )\n\n    # Create UI outputs for file inputs\n    output$treeFile_ui <- renderUI({\n        fileInput(\"treeFile\", \"Load Tree (Newick format)\",\n                 accept = c(\".tree\", \".newick\", \".nwk\"))\n    })\n    \n    output$metaFile_ui <- renderUI({\n        fileInput(\"metaFile\", \"Load Metadata (CSV format)\",\n                 accept = c(\".csv\"))\n    })\n\n    # Handle tree file upload\n    observeEvent(input$treeFile, {\n        req(input$treeFile)\n        tryCatch({\n            tree_text <- readLines(input$treeFile$datapath)\n            values$tree <- read.tree(text = tree_text)\n            \n            # Create default metadata with tip labels if no metadata is loaded\n            # if (is.null(values$metadata)) {\n            #     values$metadata <- data.frame(\n            #         name = values$tree$tip.label,\n            #         stringsAsFactors = FALSE\n            #     )\n            # }\n                values$metadata <- data.frame(\n                name = values$tree$tip.label,\n                stringsAsFactors = FALSE\n            )\n\n            output$statusMsg <- renderText(\n                paste(\"Tree file loaded:\", input$treeFile$name)\n            )\n        }, error = function(e) {\n            output$statusMsg <- renderText(\n                paste(\"Error loading tree file:\", input$treeFile$name)\n            )\n        })\n    })\n    \n    # Handle metadata file upload\n    observeEvent(input$metaFile, {\n        req(input$metaFile)\n        tryCatch({\n            values$metadata <- read.csv(input$metaFile$datapath, stringsAsFactors = FALSE)\n            output$statusMsg <- renderText(\n                paste(\"Metadata file loaded:\", input$metaFile$name)\n            )\n        }, error = function(e) {\n            output$statusMsg <- renderText(\n                paste(\"Error loading metadata file:\", input$metaFile$name)\n            )\n        })\n    })\n\n    # Handle example data loading\n    observeEvent(input$loadExample, {\n        values$tree <- read.tree(text = example_tree_text)\n        values$metadata <- example_metadata\n        output$statusMsg <- renderText(\"Example data loaded successfully!\")\n    })\n\n    # Display basic tree information\n    output$treeInfo <- renderPrint({\n        if (!is.null(values$tree)) {\n            cat(\"Tree summary:\\n\")\n            cat(\"Number of tips:\", length(values$tree$tip.label), \"\\n\")\n        } else {\n            cat(\"No tree loaded\")\n        }\n    })\n\n    # Display metadata table\n    output$metadataTable <- DT::renderDataTable({\n        req(values$metadata)\n        DT::datatable(values$metadata,\n                     options = list(pageLength = 10,\n                                  scrollX = TRUE),\n                     rownames = FALSE)\n    })\n\n    # Plot the phylogenetic tree\n    output$treePlot <- renderPlot({\n        req(values$tree)\n        par(mar = c(1, 1, 1, 1))  # Adjust margins\n        plot(values$tree, \n             cex = 0.8,           # Adjust tip label size\n             no.margin = TRUE,    # Remove margins around the plot\n             direction = \"right\") # Plot tree from left to right\n    })\n\n    # Update column choices when metadata is loaded or created\n    observe({\n        req(values$metadata)\n        updateSelectInput(session, \"splitColumn\",\n                         choices = names(values$metadata))\n        updateSelectInput(session, \"groupingColumn\",\n                         choices = names(values$metadata))\n    })\n    \n    # Add new column based on splitting using get_loc function\n    observeEvent(input$addColumn, {\n        req(values$metadata, input$splitColumn)\n        \n        # Get the column to split\n        col_data <- values$metadata[[input$splitColumn]]\n        \n        # Use get_loc function to extract tokens\n        new_col <- get_loc(col_data, \n                           delimiter = input$delimiter, \n                           index = input$position, \n                           reverse = input$reverse)\n        \n        # Create new column name\n        new_col_name <- input$newColName\n        \n        # Add the new column to the metadata\n        values$metadata[[new_col_name]] <- new_col\n        \n        # Update status message\n        output$statusMsg <- renderText(paste(\"Added new column:\", new_col_name))\n    })\n\n    # Placeholder for subsampling results\n    output$subsamplingResults <- renderPrint({\n        cat(\"Subsampling configuration:\\n\")\n        cat(\"Method:\", input$subsamplingMethod, \"\\n\")\n        if (input$subsamplingMethod == \"mono_cluster\") {\n            cat(\"Grouping by:\", input$groupingColumn, \"\\n\")\n            cat(\"Keep:\", input$keepNumber, \"\\n\")\n        }\n    })\n\n    # Handle subsampling\n    observeEvent(input$runSubsampling, {\n        req(values$tree, values$metadata)\n        \n        tryCatch({\n            if (input$subsamplingMethod == \"mono\") {\n                # Run monophyletic cluster subsampling\n                result <- downsample_tree_n_meta(\n                    tree = values$tree,\n                    meta = values$metadata,\n                    n = input$keepNumber,\n                    loc_column = input$groupingColumn\n                )\n                \n                # Store results in reactive values\n                values$node_annots <- result[[2]]\n                values$subsampled_df <- result[[1]]\n\n                toremove <- values$subsampled_df$taxa[values$subsampled_df$remove == 1]\n                values$subsampled_tree <- drop.tip(values$tree, toremove)\n                \n                # Display results\n                num_taxa <- length(values$tree$tip.label)\n                num_removed <- length(values$subsampled_df$taxa[values$subsampled_df$remove == 1])\n                output$subsamplingResults <- renderPrint({\n                    cat(\"Subsampling completed successfully!\\n\\n\")\n                    cat(\"Original tree tips:\", num_taxa, \"\\n\")\n                    cat(\"Subsampled tree tips:\", num_taxa - num_removed, \"\\n\")\n                    cat(\"Number of clusters collapsed:\", length(unique(values$subsampled_df$cluster[values$subsampled_df$remove == 1])), \"\\n\")\n                })\n                \n                # Render the subsampled table\n                output$subsampledTable <- DT::renderDataTable({\n                    req(values$subsampled_df)\n                    DT::datatable(values$subsampled_df,\n                                 options = list(pageLength = 10,\n                                              scrollX = TRUE,\n                                              title = \"Subsampled Data Table\"),\n                                 rownames = FALSE)\n                })\n                \n                # Create and switch to new tab with download buttons\n                insertTab(inputId = \"mainTabs\",\n                         tabPanel(\"Subsampling Output\",\n                                  wellPanel(\n                                    h4(\"Downsampling Output\"),\n                                    br(),\n                                    fluidRow(\n                                      column(6,\n                                            downloadButton(\"downloadDownsamplingTable\", \n                                                         \"Write Downsampling Table\",\n                                                         class = \"btn-primary\",\n                                                         style = \"width: 100%\")),\n                                      column(6,\n                                            downloadButton(\"downloadTree\", \n                                                         \"Write Downsampled Tree\",\n                                                         class = \"btn-primary\",\n                                                         style = \"width: 100%\"))\n                                    )\n                                  ),\n                                  br(),\n                                  DT::dataTableOutput(\"subsampledTable\")),\n                         target = \"Subsampling\",\n                         position = \"after\",\n                         select = TRUE)\n                \n                # Update status message\n                output$statusMsg <- renderText(\"Subsampling completed successfully!\")\n                \n            } else {\n                output$subsamplingResults <- renderPrint({\n                    cat(\"Selected subsampling method not implemented yet.\")\n                })\n            }\n        }, error = function(e) {\n            output$subsamplingResults <- renderPrint({\n                cat(\"Error during subsampling:\\n\")\n                cat(as.character(e))\n            })\n            output$statusMsg <- renderText(\"Error during subsampling!\")\n        })\n    })\n\n    # Download handler for cluster table\n    output$downloadDownsamplingTable <- downloadHandler(\n        filename = function() {\n            paste0(\"cluster_table_\", format(Sys.time(), \"%Y%m%d_%H%M%S\"), \".csv\")\n        },\n        content = function(file) {\n            write.csv(values$subsampled_df, file, row.names = FALSE)\n        }\n    )\n    \n    # Download handler for tree\n    output$downloadTree <- downloadHandler(\n        filename = function() {\n            paste0(\"downsampled_tree_\", format(Sys.time(), \"%Y%m%d_%H%M%S\"), \".nwk\")\n        },\n        content = function(file) {\n            ape::write.tree(values$subsampled_tree, file)\n        }\n    )\n\n    # Clear data should also clear the subsampled results and remove the tab\n    observeEvent(input$clearData, {\n        values$tree <- NULL\n        values$metadata <- NULL\n        values$subsampled_tree <- NULL\n        values$subsampled_metadata <- NULL\n        values$subsampled_df <- NULL\n        values$show_tree_info_plot <- NULL\n        \n        # Remove the Subsampling Output tab if it exists\n        removeTab(inputId = \"mainTabs\", target = \"Subsampling Output\")\n        \n        # Reset file inputs by recreating them\n        output$treeFile_ui <- renderUI({\n            fileInput(\"treeFile\", \"Load Tree (Newick format)\",\n                     accept = c(\".tree\", \".newick\", \".nwk\"))\n        })\n        output$metaFile_ui <- renderUI({\n            fileInput(\"metaFile\", \"Load Metadata (CSV format)\",\n                     accept = c(\".csv\"))\n        })\n        \n        # Reset other inputs to default values\n        updateSelectInput(session, \"splitColumn\", choices = NULL)\n        updateTextInput(session, \"newColName\", value = \"\")\n        updateTextInput(session, \"delimiter\", value = \"_\")\n        updateNumericInput(session, \"position\", value = 1)\n        updateSelectInput(session, \"reverse\", selected = FALSE)\n        \n        # Reset subsampling tab inputs\n        updateSelectInput(session, \"subsamplingMethod\", selected = \"mono\")\n        updateSelectInput(session, \"groupingColumn\", choices = NULL)\n        updateNumericInput(session, \"keepNumber\", value = 1)\n        \n        # Clear the subsampling results output\n        output$subsamplingResults <- renderPrint({\n            cat(\"\")  # Empty output\n        })\n        \n        # Update status message\n        output$statusMsg <- renderText(\"All data cleared!\")\n        \n        # Remove the download handlers\n        output$downloadDownsamplingTable <- NULL\n        output$downloadTree <- NULL\n    })\n\n    # Handle Plot Tree button\n    observeEvent(input$plotTreeInfo, {\n        req(values$tree)\n        values$show_tree_info_plot <- TRUE\n    })\n    \n    # Handle Clear Plot button\n    observeEvent(input$clearTreeInfoPlot, {\n        values$show_tree_info_plot <- NULL\n    })\n    \n    # Plot in Tree Info tab\n    output$treeInfoPlot <- renderPlot({\n        req(values$tree, values$show_tree_info_plot)\n        par(mar = c(1, 1, 1, 1))  # Adjust margins\n        plot(values$tree, \n            show.tip.label = FALSE,\n            edge.width = 0.4,\n            cex = 0.8,           # Adjust tip label size\n            no.margin = TRUE,    # Remove margins around the plot\n            direction = \"right\") # Plot tree from left to right\n    })\n\n    # Render tree info buttons\n    output$treeInfoButtons <- renderUI({\n        fluidRow(\n            column(6,\n                   if (!is.null(values$tree)) {\n                       actionButton(\"plotTreeInfo\", \"Plot Tree\",\n                                  class = \"btn-primary\",\n                                  style = \"width: 100%\")\n                   }),\n            column(6,\n                   if (!is.null(values$show_tree_info_plot)) {\n                       actionButton(\"clearTreeInfoPlot\", \"Clear Plot\",\n                                  class = \"btn-warning\",\n                                  style = \"width: 100%\")\n                   })\n        )\n    })\n    \n    # Render tree info plot container\n    output$treeInfoPlotContainer <- renderUI({\n        if (!is.null(values$show_tree_info_plot)) {\n            plotOutput(\"treeInfoPlot\", height = \"calc(100vh - 300px)\")\n        }\n    })\n    \n    # Show/hide Subsampling Output tab\n    observe({\n        if (!is.null(values$subsampled_df)) {\n            showTab(inputId = \"mainTabs\", target = \"Subsampling Output\")\n        } else {\n            hideTab(inputId = \"mainTabs\", target = \"Subsampling Output\")\n        }\n    })\n\n}\n","type":"text"},{"name":"ui.R","content":"#\n# This is the user-interface definition of a Shiny web application. You can\n# run the application by clicking 'Run App' above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    https://shiny.posit.co/\n#\n\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui <- fluidPage(\n  # Add CSS to hide the file input progress bar\n  tags$head(\n    tags$style(\"\n      .shiny-file-input-progress {display: none}\n      /* Style for subtitle */\n      .subtitle {\n        font-size: 1em;\n        color: #666;\n        margin-top: -10px;\n        margin-bottom: 20px;\n      }\n    \")\n  ),\n\n  # Title and subtitle\n  titlePanel(\n    div(\n      h1(\"PhyloDiSH: Phylogenetic Downsampling in Shiny\"),\n      tags$div(style = \"height: 4px;\"),  # Add a div with height of 4px for empty space\n    #   p(class = \"subtitle\", \"Phylogenetic Downsampling in Shiny\")\n    ),\n    windowTitle = \"PhyloDiSH\"  # This is what shows in the browser tab\n  ),\n\n  # Sidebar with a slider input for number of bins\n  sidebarLayout(\n    sidebarPanel(\n      width = 3,\n      # Example data button first\n      actionButton(\"loadExample\", \"Load Example Data\",\n                  style = \"width: 100%;\"),\n      \n      hr(),\n      \n      # File input buttons using uiOutput\n      uiOutput(\"treeFile_ui\"),\n      uiOutput(\"metaFile_ui\"),\n      \n      hr(),\n      \n      # Clear data button\n      actionButton(\"clearData\", \"Clear Data\",\n                  class = \"btn-warning\",  # Makes the button yellow\n                  style = \"margin-top: 10px; width: 100%;\"),  # Adds spacing and makes button full width\n      \n      hr(),\n      \n      # Status message\n      textOutput(\"statusMsg\")\n    ),\n\n        mainPanel(\n            width = 9,\n            tabsetPanel(\n                id = \"mainTabs\",\n                tabPanel(\"Tree Info\", \n                         fluidRow(\n                             column(12,\n                                    wellPanel(\n                                        # Tree information below the plot\n                                        verbatimTextOutput(\"treeInfo\"),\n                                        # Buttons container\n                                        uiOutput(\"treeInfoButtons\"),\n                                        # Add some space\n                                        br(),\n                                        # Conditional plot output\n                                        uiOutput(\"treeInfoPlotContainer\")\n                                    )\n                             )\n                         )),\n                tabPanel(\"Metadata\", \n                         # Add controls for column splitting\n                         fluidRow(\n                             column(12,\n                                    wellPanel(\n                                        h4(\"Add New Column\"),\n                                        # First row\n                                        fluidRow(\n                                            column(6,\n                                                   textInput(\"newColName\", \"New Column Name:\",\n                                                             value = \"\")),\n                                            column(6,\n                                                   selectInput(\"splitColumn\", \"Column to split:\",\n                                                             choices = NULL))\n                                        ),\n                                        # Second row\n                                        fluidRow(\n                                            column(2,\n                                                   textInput(\"delimiter\", \"Delimiter:\",\n                                                             value = \"_\", width = \"80px\")),\n                                            column(3,\n                                                   numericInput(\"position\", \"Position:\",\n                                                              value = 1, min = 1)),\n                                            column(3,\n                                                   selectInput(\"reverse\", \"Reverse:\",\n                                                             choices = c(\"FALSE\" = FALSE, \n                                                                       \"TRUE\" = TRUE),\n                                                             selected = FALSE)),\n                                            column(4,\n                                                   br(),\n                                                   actionButton(\"addColumn\", \"Add Column\",\n                                                              class = \"btn-primary\"))\n                                        )\n                                    )\n                             )\n                         ),\n                         DT::dataTableOutput(\"metadataTable\")),\n                tabPanel(\"Subsampling\",\n                         wellPanel(\n                             h4(\"\"),\n                             fluidRow(\n                                 column(6,\n                                        selectInput(\"subsamplingMethod\", \n                                                  \"Subsampling Method:\",\n                                                  choices = c(\"monophyletic cluster\" = \"mono\"))\n                                 )\n                             ),\n                             conditionalPanel(\n                                 condition = \"input.subsamplingMethod == 'mono'\",\n                                 fluidRow(\n                                     column(6,\n                                            selectInput(\"groupingColumn\", \n                                                      \"Group by:\",\n                                                      choices = NULL)\n                                     ),\n                                     column(4,\n                                            numericInput(\"keepNumber\",\n                                                       \"Keep:\",\n                                                       value = 1,\n                                                       min = 1)\n                                     )\n                                 )\n                             ),\n                             fluidRow(\n                                 column(12,\n                                        actionButton(\"runSubsampling\", \"Run Subsampling\",\n                                                   class = \"btn-primary\",\n                                                   style = \"margin-top: 15px; width: 100%\")\n                                 )\n                             )\n                         ),\n                         wellPanel(\n                             h4(\"Results\"),\n                             verbatimTextOutput(\"subsamplingResults\")\n                         )),\n                # Conditional tab for subsampling results\n                tabPanelBody(\"Subsampling Table\",\n                             value = \"subsamplingTable\",\n                             DT::dataTableOutput(\"subsampledTable\"))\n            )\n        )\n    )\n)","type":"text"},{"name":"example_files/example_metadata.csv","content":"name,loc\nA1_A,A\nA2_A,A\nA3_A,A\nA4_A,A\nB1_B,B\nB2_B,B\nB3_B,B\nB4_B,B\nB5_B,B\nB6_B,B\nC1_C,C\nC2_C,C\nC3_C,C\n","type":"text"},{"name":"example_files/example_tree.tre","content":"((((A1_A,A2_A),(A3_A,A4_A)),((B1_B,B2_B),((B3_B,B4_B),(B5_B,B6_B)))),((C1_C,C2_C),C3_C));","type":"text"},{"name":"subsampling.R","content":"library(ape)\n\n# Helper functions\n# Get location from string using delimiter and index\nget_loc <- function(string, delimiter, index, reverse = FALSE) {\n  if (reverse == TRUE) {\n    splitted <- strsplit(string, split = delimiter, fixed = TRUE)\n    reved <- lapply(splitted, rev)\n    return(lapply(reved, \"[[\", index))\n  } else {\n    return(unlist(lapply(strsplit(string, split = delimiter, fixed = TRUE),\n                  \"[[\", index)))\n  }\n}\n\n# Get location from metadata file dataframe and taxon name\nget_loc_from_meta <- function(n, metadf, loc_column) {\n  loc <- metadf[metadf$name == n, loc_column]\n  return(as.character(loc))\n}\n\n# Get an array of locations given an array of names and a metadata file\nget_loc_array_meta <- function(name_array, meta, loc_column) {\n  locs <- sapply(name_array, get_loc_from_meta, metadf = meta, loc_column = loc_column)\n  return(as.character(locs))\n}\n\n# Get the descendant nodes given an ape tree and a node number\nget_descendants <- function(tree, node) {\n  if (node <= length(tree$tip.label)) {\n    return(-1)\n  } else {\n    return(tree$edge[which(tree$edge[, 1] == node), 2])\n  }\n}\n\n# Get all descendants of a node given an ape tree\nget_all_descendants <- function(tree, node, curr = NULL) {\n  if (!inherits(tree, \"phylo\")) {\n    stop(\"tree should be an object of class \\'phylo\\'.\")\n  }\n\n  if (is.null(curr)) {\n    curr <- vector()\n  }\n\n  daughters <- tree$edge[tree$edge[, 1] == node, 2]\n  curr <- c(curr, daughters)\n\n  if (length(curr) == 0 && node <= Ntip(tree)) {\n    curr <- node\n  }\n\n  w <- which(daughters > Ntip(tree))\n\n  if (length(w) > 0) {\n    for (i in seq_along(w)) {\n      curr <- get_all_descendants(tree, daughters[w[i]], curr)\n    }\n  }\n\n  return(curr)\n}\n\n# Get the descendant tips from a given node\nget_tips_from_node <- function(tree, node) {\n  desc <- get_all_descendants(tree, node, curr = NULL)\n  return(desc[desc <= length(tree$tip.label)])\n}\n\n# Get the node annotations given a tip annotation.\n# If all descendant tips are the same, the node has the same annotation,\n# otherwise the annotation is MIXED\nget_node_annots <- function(tree, tip_annot) {\n  tree <- reorder(tree, \"pruningwise\")\n  num_nodes <- (length(tree$tip.label) + tree$Nnode)\n  node_annot_list <- rep(0, length = num_nodes)\n  rootnode <- length(tree$tip.label) + 1\n  for (node in c(as.array(tree$edge[, 2]), rootnode)) {\n    if (node <= length(tree$tip.label)) {\n      node_annot_list[node] <- tip_annot[node]\n    } else {\n      children_nodes <- get_descendants(tree, node)\n      locs_in_children <- c()\n      for (c in children_nodes) {\n        locs_in_children <- c(locs_in_children, node_annot_list[c])\n      }\n      locs_in_children <- unique(unlist(locs_in_children))\n      if ((\"MIXED\" %in% locs_in_children) || (length(locs_in_children) > 1)) {\n        node_annot_list[node] <- \"MIXED\"\n      } else {\n        node_annot_list[node] <- node_annot_list[c]\n      }\n    }\n  }\n  return(node_annot_list)\n}\n\nget_clusters <- function(tree, node_annot) {\n  non_mixed <- which(node_annot != \"MIXED\")\n  children_nodes <- c()\n  for (internal_node in non_mixed[non_mixed > length(tree$tip.label)]) {\n    children_nodes <- c(children_nodes, get_descendants(tree, internal_node))\n  }\n  return(setdiff(non_mixed[non_mixed > length(tree$tip.label)], children_nodes))\n}\n\nprune_clusters <- function(tree, cluster_nodes) {\n  toremove_df <- data.frame(taxa = tree$tip.label, \n                           cluster = 0,\n                           remove = 0)\n  for (c in cluster_nodes) {\n    subtree_tips <- tree$tip.label[get_tips_from_node(tree, c)]\n    filtered <- sample(subtree_tips, length(subtree_tips) - 1)\n    toremove_df$cluster[toremove_df$taxa %in% subtree_tips] <- c\n    toremove_df$remove[toremove_df$taxa %in% filtered] <- 1\n  }\n  return(toremove_df)\n}\n\ndownsample_tree <- function(tree, split_char, split_index, reverse) {\n  num_taxa <- length(tree$tip.label)\n  # Get tip annotations by delimiter and index, \n  # use reverse to count from the back\n  tip_annot <- get_loc(tree$tip.label, split_char, split_index, reverse)\n  node_annots <- get_node_annots(tree, tip_annot)\n  clusters <- get_clusters(tree, node_annots)\n  toremove_df <- prune_clusters(tree, clusters)\n  num_removed <- length(toremove_df$taxa[toremove_df$remove == 1])\n  print(sprintf(\"Tree pruned from %d taxa to %d after collapsing %d clusters\",\n                num_taxa, num_taxa - num_removed, length(clusters)))\n  return(list(toremove_df, node_annots))\n}\n\n# From metadata file with location annotated as loc\ndownsample_tree_meta <- function(tree, meta, loc_column) {\n  num_taxa <- length(tree$tip.label)\n  # Get tip annotations by delimiter and index, use reverse to count from back\n  tip_annot <- get_loc_array_meta(tree$tip.label, meta, loc_column)\n  node_annots <- get_node_annots(tree, tip_annot)\n  clusters <- get_clusters(tree, node_annots)\n  toremove_df <- prune_clusters(tree, clusters)\n  num_removed <- length(toremove_df$taxa[toremove_df$remove == 1])\n  print(sprintf(\"Tree pruned from %d taxa to %d after collapsing %d clusters\",\n                num_taxa, num_taxa - num_removed, length(clusters)))\n  return(list(toremove_df, node_annots))\n}\n\ndownsample_tree_n_meta <- function(tree, meta, n, loc_column) {\n  num_taxa <- length(tree$tip.label)\n  tip_annot <- get_loc_array_meta(tree$tip.label, meta, loc_column)\n  node_annots <- get_node_annots(tree, tip_annot)\n  clusters <- get_clusters(tree, node_annots)\n  toremove_df <- prune_clusters_n(tree, clusters, n)\n  num_removed <- length(toremove_df$taxa[toremove_df$remove == 1])\n  print(sprintf(\"Tree pruned from %d taxa to %d after collapsing %d clusters\",\n                num_taxa, num_taxa - num_removed, length(clusters)))\n  return(list(toremove_df, node_annots))\n}\n\nprune_clusters_n <- function(tree, cluster_nodes, n) {\n  toremove_df <- data.frame(taxa = tree$tip.label,\n                           cluster = 0,\n                           remove = 0)\n  for (c in cluster_nodes) {\n    subtree_tips <- tree$tip.label[get_tips_from_node(tree, c)]\n    toremove_df$cluster[toremove_df$taxa %in% subtree_tips] <- c\n    subtree_size <- length(subtree_tips)\n    if (subtree_size > n) {\n      filtered <- sample(subtree_tips, subtree_size - n)\n      toremove_df$remove[toremove_df$taxa %in% filtered] <- 1\n    } else {\n      filtered <- NA\n    }\n  }\n  return(toremove_df)\n}\n\n# Keep only N per cluster\ndownsample_tree_n <- function(tree, n, split_char, split_index, reverse) {\n  num_taxa <- length(tree$tip.label)\n  # Get tip annotations by delimiter and index, use reverse to count from back\n  tip_annot <- get_loc(tree$tip.label, split_char, split_index, reverse)\n  node_annots <- get_node_annots(tree, tip_annot)\n  clusters <- get_clusters(tree, node_annots)\n  toremove_df <- prune_clusters_n(tree, clusters, n)\n  num_removed <- length(toremove_df$taxa[toremove_df$remove == 1])\n  print(sprintf(\"Tree pruned from %d taxa to %d after collapsing %d clusters. %d taxa removed.\",\n                num_taxa, num_taxa - num_removed, length(clusters), num_removed))\n  return(list(toremove_df, node_annots))\n}\n","type":"text"},{"name":"tests.R","content":"source(\"subsampling.R\")\n\n#Test the functions with a test newick tree and metadata\n# load test_newick\ntree <- ape::read.tree(\"example_files/example_tree.tre\")\n\n# Create a test dataframe with name and location columns\nmeta <- read.csv(\"example_files/example_metadata.csv\")\n\n\n# Test get_loc function\nprint(\"Testing get_loc\")\ntest_locs <- get_loc(tree$tip.label,'_',2)\nexpected_locs <- meta$loc\nstopifnot(all(test_locs == expected_locs))\n\n# Test get_loc_from_meta function\nprint(\"Testing get_loc_from_meta\")\ntest_name <- \"A1_A\" \ntest_loc <- get_loc_from_meta(test_name, meta)\nstopifnot(test_loc == \"A\")\n\n# Test get_loc_array_meta function\nprint(\"Testing get_loc_array_meta\")\ntest_names <- c(\"A1_A\", \"B2_B\", \"C3_C\")\ntest_locs <- get_loc_array_meta(test_names, meta)\nexpected_locs <- c(\"A\", \"B\", \"C\")\nstopifnot(all(test_locs == expected_locs))\n\n# Test get_descendants function\nprint(\"Testing get_descendants\")\ntest_node <- 16 # Internal node\ndescendants <- get_descendants(tree, test_node)\nstopifnot(length(descendants) > 0)\n\ntest_tip <- 1 # Tip node\ntip_descendants <- get_descendants(tree, test_tip)\nstopifnot(tip_descendants == -1)\n\n# Test get_all_descendants function\nprint(\"Testing get_all_descendants\")\ntest_node <- 14 #root \nall_descendants <- get_all_descendants(tree, test_node)\nstopifnot(length(all_descendants) == 24)\n\n#test get_tips_from_node\nprint(\"Testing get_tips_from_node\")\ntest_node <- length(tree$tip.label)+1 \nall_tips <- get_tips_from_node(tree,test_node)\nstopifnot(length(all_tips) == test_node-1)\n\n# Test downsample_tree_meta function\nprint(\"Testing downsample_tree_meta\")\nresults <- downsample_tree_meta(tree, meta)\ntoremove_df <- results[[1]]\nnum_taxa <- length(tree$tip.label)\nnum_removed <- length(toremove_df$taxa[toremove_df$remove == 1])\nnode_annots <- results[[2]]\nstopifnot(is.data.frame(toremove_df))\nstopifnot(num_taxa - num_removed == 3)\n\n# Test downsample_tree_n function\nprint(\"Testing downsample_tree_n\")\nn <- 2\nresults_n <- downsample_tree_n(tree, n, \"_\", 2, FALSE)\ntoremove_df_n <- results_n[[1]]\nnum_removed_n <- length(toremove_df_n$taxa[toremove_df_n$remove == 1])\nnode_annots_n <- results_n[[2]]\nstopifnot(is.data.frame(toremove_df_n))\nstopifnot(num_taxa - num_removed_n == 6)\n\nprint(\"All tests passed!\")\n","type":"text"},{"name":"utils.R","content":"#' Reset a file input control to its initial state\n#' @param inputId The ID of the file input control\n#' @param session The current session object\nreset_file_input <- function(inputId, session) {\n    # Create a new file input with the same properties\n    if(inputId == \"treeFile\") {\n        session$output[[paste0(inputId, \"_ui\")]] <- renderUI({\n            fileInput(\"treeFile\", \"Load Tree (Newick format)\",\n                     accept = c(\".tree\", \".newick\", \".nwk\"))\n        })\n    } else if(inputId == \"metaFile\") {\n        session$output[[paste0(inputId, \"_ui\")]] <- renderUI({\n            fileInput(\"metaFile\", \"Load Metadata (CSV format)\",\n                     accept = c(\".csv\"))\n        })\n    }\n} ","type":"text"}]
